import{aI as e,az as t,V as a,ax as r,aJ as i,aK as s,aA as o}from"../vendor.js";import{v as l,f as n}from"../FakeMirrorVertex.js";class p{constructor(e){var{artifact:t,mergeConfig:a}=e;this.shaderConfig=a(t,{filterSize:"1.0",minDepth:"0.1",maxDepth:"5.0",depthThresholdFilter:"0.9",scale:"2.0",ptSize:"1.0",depthScale:"0.1",pixelDepth:"1.0",ifx:.00125,ify:.00125,itx:-.4,ity:-.6,ptSize:"1.0",textures:{}})}afterLoadModel(t){var{engine:a,preload:r}=t,{model:i}=a,{textures:s}=r.assets,o=Object.entries(s);if(null!=o&&o.length){var l=new e;l.name="textureGroup";var{target:n}=a.artifact.textures;o.forEach(((e,t)=>{var[a,r]=e,s=i.getObjectByName("".concat(n,"_").concat(t+1)),o=this.createPoints(r,s);l.add(o)})),i.add(l)}else console.error("scenes/FakeMirrorImages: preload.assets.textures not defined",{engine:a,preload:r,textures:s})}createPoints(p,d){var h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"1.0",{image:f}=p,{width:c,height:u}=f,v=new e;v.position.copy(d.position),v.rotation.copy(d.rotation),v.scale.copy(d.scale);for(var{ifx:x=.00125,ify:y=.00125,itx:m=-.4,ity:g=-.6,filterSize:S,minDepth:w,maxDepth:z,depthScale:D,depthThresholdFilter:F,scale:A,ptSize:I,pixelDepth:j}=this.shaderConfig,C={texImg:{type:"t",value:p},texSize:{type:"i2",value:[c,u]},iK:{type:"f4",value:[x,y,m,g]},alpha:{type:"f",value:h},filterSize:{type:"f",value:S},minDepth:{type:"f",value:w},maxDepth:{type:"f",value:z},depthThresholdFilter:{type:"f",value:F},scale:{type:"f",value:A},ptSize:{type:"f",value:(I*window.devicePixelRatio).toFixed(1).toString()},pixelDepth:{type:"f",value:j},depthScale:{type:"f",value:D}},b=new t({uniforms:C,side:a,transparent:!0,vertexShader:l,fragmentShader:n}),M=c/2*u,P=new Uint32Array(M),T=new Float32Array(M),k=0;k<M;k++)P[k]=k,T[k]=k;var K=new r;K.setAttribute("vertexIdx",new i(T,1)),K.setIndex(new s(new Uint32Array(P),1));var O=new o(K,b);return O.frustumCulled=!1,v.add(O),v}}export{p as default};
